# 演算法
----
## 何謂演算法
* 就是...解決問題的方法
* 用程式語言
----
## List
* 枚舉
* 貪心(Greedy)
* 二分搜(Binary Search)
* 分治(Divide and Conquer)
------
# 枚舉
----
## 回朔
* 使用遞迴
* 遇到不可能的情形就停止
----
## 特殊枚舉
* 二進位
* 字典序
----
## 折半枚舉
* $2^n$會TLE
* 將$n$分成兩半，複雜度降為$\sqrt{2^n}$
----
## 題目
* UVa 11059(區間列舉)
* UVa 1481(區間列舉)
* UVa 10976(減少列舉範圍)
* UVa 750(回朔)
* UVa 524(回朔)
* UVa 11464
* UVa 1326(折半枚舉)
------
# 貪心
----
* 用同一種方法
* 保持最有利狀態
----
## 證明
* 以免解到一半才發現是錯的
----
### 方法1
* 試圖構造出反例,發現他不存在。
----
### 方法2
* 如果存在更佳解的答案比你做出來的還好,那這組解一定可以再做得更好,進而達到反證出更佳解不存在。
----
### 方法3
* 使用遞迴證法
  1. 證明基底是對的。
  2. 假設小問題是好的。
  3. 你一定可以用最好的方法來將問題簡化成剛才假設是好的小問題。
----
## 題目
* UVa 11729
* UVa 11292
* UVa 11389
* UVa 1445
* UVa 993
* TIOJ 1441
------
# 二分搜
----
* 對於一個函數$F(n)$，如果存在一個x，對於所有 $\geq x$ 的a，$F(a)=$ true，反之$F(a)=$ false基於這樣的單調性，就可以用二分搜。
----
```cpp
T binary_search(){
    while(L<R){
        int M=(L+R)>>1;
        if(F(M))R=M;
        else L=M+1;
    }
    return L;
}
```
----
## 注意
* 避免無限迴圈
* 實數中二分搜
----
## 三分搜
* 對付U型函數
----
考慮三分後從左到右四個採樣點的關係
* $S(a) < S(b) < S(c) < S(d)$，此時最小值一定不在最右邊
* $S(a) > S(b) < S(c) < S(d)$，此時最小值一定不在最右邊
* $S(a) > S(b) > S(c) < S(d)$，此時最小值一定不在最左邊
* $S(a) > S(b) > S(c) > S(d)$，此時最小值一定不在最左邊
----
簡化
* $S(b) < S(c)$，此時最小值一定不在最右邊
* $S(b) > S(c)$，此時最小值一定不在最左邊
----
```cpp
double trinary_search(double l,double r){
static const double EPS=1e−7;
while(r−l>EPS){
        double ml=(l+l+r)/3,mr=(l+r+r)/3;
        if(f(mr)>f(ml)) r=mr;
        else l=ml;
    }
    return l;
}
```
----
## 題目
* Uva 714
* Uva 1421
* Uva 11627
* neoj 72(三分搜)
------
# 分治
----
* 分治法會把問題分解成子問題(分)
* 解決完再合併回原本的問題(治)
----
## 步驟
* 切割：把一個問題切成子問題然後遞迴
* 碰底：碰到不能再切割或是明顯有答案(也許無解)，就算出答案再回傳
* 合併：利用傳回來的子問題算出答案然後回傳
----
## 合併排序法
一個利用分治實作的排序法，逆序數對也會利用他的概念來實作。
----
* 切割：把序列分成兩半然後遞迴
* 碰底：直到序列長度為1，這時候已為一個排好的序列，直接回傳
* 合併：利用傳回來的兩串序列進行排序
----
```cpp
using namespace std;
const int N = 100;
int arr[N], buf[N];
void sol(int L, int R) { // [L,R)
	if (R - L <= 1)return;
	int M = (R + L) / 2;
	sol(L, M);
	sol(M, R);
	int i = L, j = M, k = L;
	while (i < M || j < R) {
		if (i >= M)
			buf[k] = arr[j++];
		else if (j >= R)
			buf[k] = arr[i++];
		else {
			if (arr[i] <= arr[j])
				buf[k] = arr[i++];
			else {
				buf[k] = arr[j++];
			}
		}
		k++;
	}
	for (int k = L; k < R; k++) arr[k] = buf[k];
	return;
}
```
----
## 更多的經典題目
* 快速排序法。
* 逆序數對。(經典問題,搭配 Merge Sort)
----
## 題目
* uva 1608
* uva 10810(逆序數對)
* uva 11129
* uva 10245